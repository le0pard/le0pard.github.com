---
layout: post
title: Быстрое сравнение изображений с помощью Ruby(PHP) и PostgreSQL
wordpress_id: 1085
wordpress_url: http://leopard.in.ua/?p=1085
categories:
- Ruby
- postgresql
- интересно
- разработка
- PHP
- Ruby on Rails
tags:
- интересно
- Ruby on Rails
- разработка
- Ruby
- postgresql
---
Добрый день, дорогой друг. Сегодня я расскажу как я произвожу поиск похожих изображений для одного проекта. Сразу хочу сказать, что точность алгоритма очень мала: он не учитывает повернутые изображение, части того же изображения. Алгоритм помогает найти похожие изображения, которые например незначительно отличаются (изображение обесцветили, добавили ватермарк, пропустили через фильтры). Но, поскольку точность мала, то у алгоритма есть и позитивная сторона - скорость работы. Итак, начнем.<!--more-->Начнем с простого. Как можно определить, что приложения похожи? Самый простой метод - сравнивать попиксельно два изображения (если у изображений разные размеры - изменяем размер к одному). Но скорость такой работы будет не велика на больших разрешениях изображений. Тем более, такой метод не учитывает, что могли изменять уровень света, насыщенность и прочее у изображения.В нашем алгоритме мы будет создавать пиксельную матрицу к любому изображению: производить изменения размера изображения к требующему. Пусть она будет 15х15 пикселей. Следующим шагом мы будет узнавать не цвет пикселя, а его интенсивность (интенсивность вычисляется по формуле 0.299*крастный+0.587*зеленый+0.114*синий). Вычисляя интенсивность поможет нам находит изображения не обращая внимание на используемые цвета в них.
[![Пиксельная матрица](http://leopard.in.ua/wp-content/uploads/2010/12/1-300x225.jpg "Пиксельная матрица")](http://leopard.in.ua/wp-content/uploads/2010/12/1.jpg)
После того, как вы вычислили интенсивность всех пикселей в матрицу 15х15, мы узнаем отношение интенсивности каждого пикселя к среднему значению интенсивности по матрице и генерируем уникальное число для каждой ячейки (в коде для уникальности генерации для каждой ячейки мы добавляем к интенсивности её координаты) и получаем массив длинной 225 елементов (15*15=225). Отлично.
[![Пиксельная матрица](http://leopard.in.ua/wp-content/uploads/2010/12/2-300x124.jpg "Пиксельная матрица")](http://leopard.in.ua/wp-content/uploads/2010/12/2.jpg)
Для находждения похожих изображений используем следующий алгоритм:
**((количество элементов(array1 & array2)) / 225) * 100 = процент сходства двух изображений**
где "array1 &amp; array2" возвращает массив, содержащий все значения array1, которые присутствуют в array2. Вычислив размер полученного массива и после этого поделив его на размер массива в общем (225), мы получим коофициент сходства этих изображений (умножив на 100 - процент сходства). Вот и все.## Практическая часть
Ну а теперь наконец код:Класс на Ruby ([ссылка на код](https://gist.github.com/733938)):<pre lang="ruby">require 'RMagick'class ImageDiff#max = 20MATRIX = 15def generate_array(image_path)result = []main_img = Magick::Image.read(image_path).firstunless main_img.nil?main_img.resize!(MATRIX, MATRIX)pixel_array = []avr_pixel = 0MATRIX.times do |i|pixel_array[i] = []MATRIX.times do |j|temp_pixel = main_img.pixel_color(i, j)pixel_array[i][j] = temp_pixel.intensity()avr_pixel += pixel_array[i][j]endendavr_pixel = avr_pixel.to_f / (MATRIX * MATRIX);MATRIX.times do |i|MATRIX.times do |j|row = (pixel_array[i][j] == 0) ? 0 : (2*((pixel_array[i][j] &gt; avr_pixel) ? pixel_array[i][j].to_f / avr_pixel : (avr_pixel.to_f / pixel_array[i][j]) * -1)).roundrow_str = "#{i + 10}#{j + 10}#{255 + row}"result &lt;&lt; row_str.to_iendendendreturn resultenddef diff_images(image_path1, image_path2)res_array1 = generate_array(image_path1)res_array2 = generate_array(image_path2)main_array = res_array1 &amp; res_array2return sprintf('%.6f', (main_array.length.to_f / (MATRIX * MATRIX)))endend</pre>Класс на PHP ([ссылка на код](https://gist.github.com/733942)):<pre lang="php">&lt;?phpclass ImageDiff { // not bigger 20 private $matrix = 20; public function getImageInfo($image_path){ list($width, $height, $type, $attr) = getimagesize($image_path); $image_type = ''; switch ($type) { case IMAGETYPE_JPEG: $image_type = 'jpeg'; break; case IMAGETYPE_GIF: $image_type = 'gif'; break; case IMAGETYPE_PNG: $image_type = 'png'; break; case IMAGETYPE_BMP: $image_type = 'bmp'; break; default: $image_type = ''; } return array('width' =&gt; $width, 'height' =&gt; $height, 'type' =&gt; $image_type); } public function generateArray($image_path){ $image_info = $this-&gt;getImageInfo($image_path); $func = 'imagecreatefrom'.$image_info['type']; if (function_exists($func)){ $main_img = $func($image_path); $tmp_img = imagecreatetruecolor($this-&gt;matrix, $this-&gt;matrix); imagecopyresampled($tmp_img, $main_img, 0, 0, 0, 0, $this-&gt;matrix, $this-&gt;matrix, $image_info['width'], $image_info['height']); $pixelmap = array(); $average_pixel = 0; for($x = 0; $x &lt; $this-&gt;matrix; $x++){ for($y = 0; $y &lt; $this-&gt;matrix; $y++){ $color = imagecolorat($tmp_img, $x, $y); $color = imagecolorsforindex($tmp_img, $color); $pixelmap[$x][$y]= 0.299 * $color['red'] + 0.587 * $color['green'] + 0.114 * $color['blue']; $average_pixel += $pixelmap[$x][$y]; } } $average_pixel = $average_pixel/($this-&gt;matrix * $this-&gt;matrix); imagedestroy($main_img); imagedestroy($tmp_img); for($x = 0; $x &lt; $this-&gt;matrix; $x++){ for($y = 0; $y &lt; $this-&gt;matrix; $y++){ $row = ($pixelmap[$x][$y] == 0) ? 0 : (round( 2*(($pixelmap[$x][$y] &gt; $average_pixel) ? $pixelmap[$x][$y] / $average_pixel : ($average_pixel/$pixelmap[$x][$y]) * -1))); $row = ($x + 10).($y + 10).(255 + $row); $result[] = intval($row); } } return $result; } else { //raise exception throw new Exception('File type  not supported!'); } } public function diffImages($image_path1, $image_path2){ $array1 = $this-&gt;generateArray($image_path1); $array2 = $this-&gt;generateArray($image_path2); $result = 0; $result = count( array_intersect($array1, $array2) ); return round($result / ( $this-&gt;matrix * $this-&gt;matrix ), 6); }}?&gt;</pre>## Использование:
Ruby:<pre lang="ruby">img_diff = ImageDiff.newimage_path1 = "#{Rails.root}/public/test_diff/1.jpg"image_path2 = "#{Rails.root}/public/test_diff/2.jpg"img_diff.diff_images(image_path1, image_path2)=&gt; "0.608889"</pre>PHP:<pre lang="php">$image_path1 = "1.jpg";$image_path2 = "3.jpg";$image_diff = new ImageDiff();echo $image_diff-&gt;diffImages($image_path1, $image_path2);=&gt; "0.5825"</pre>**ВНИМАНИЕ! **У Ruby и PHP немного разные проценты на изображения, поскольку в ruby используется ImageMagick для работы с изображениями, а в PHP - GD2 (класс с PHP можно переписать для работы с ImageMagick).### Примеры:
<table><tbody><tr><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/chart2.png "chart2")](http://leopard.in.ua/wp-content/uploads/2010/12/chart2.png)</td><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/chart1.png "chart1")](http://leopard.in.ua/wp-content/uploads/2010/12/chart1.png)</td></tr><tr><td style="padding: 5px; text-align: center;" colspan="2">### 61,33% совпадения
</td></tr></tbody></table><table><tbody><tr><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/11-300x168.jpg "1")](http://leopard.in.ua/wp-content/uploads/2010/12/11.jpg)</td><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/3-300x168.jpg "3")](http://leopard.in.ua/wp-content/uploads/2010/12/3.jpg)</td></tr><tr><td style="padding: 5px; text-align: center;" colspan="2">### 94,66% совпадения
</td></tr></tbody></table><table><tbody><tr><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/111-300x240.jpg "11")](http://leopard.in.ua/wp-content/uploads/2010/12/111.jpg)</td><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/12-300x225.png "12")](http://leopard.in.ua/wp-content/uploads/2010/12/12.png)</td></tr><tr><td style="padding: 5px; text-align: center;" colspan="2">### 0,89% совпадения
</td></tr></tbody></table><table><tbody><tr><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/11-300x300.png "11")](http://leopard.in.ua/wp-content/uploads/2010/12/11.png)</td><td>[![](http://leopard.in.ua/wp-content/uploads/2010/12/12-264x300.gif "12")](http://leopard.in.ua/wp-content/uploads/2010/12/12.gif)</td></tr><tr><td style="padding: 5px; text-align: center;" colspan="2">### 23,56% совпадения
</td></tr></tbody></table>## Поиск по базе данных
Отлично, но это для сравнения двух изображений. А как производить поиск похожих изображений? Для этого мы будем использовать PostgreSQL базу данных. У PostgreSQL есть тип поля массив. По умолчанию PostgreSQL не сильно умеет оперировать с массивами, но его можно научить. Для этого в БД я загрузил дополнительный набор функций - [intarray](http://www.postgresql.org/docs/current/static/intarray.html). Из них нам потребуется функция "icount" (вычисляет размер массива) и "&amp;" (возвращает массив, содержащий все значения array1, которые присутствуют в array2). Для проверки работоспособности функций можно простым запросом:<pre lang="sql"># SELECT icount('{1,2,3}'::int[]);icount--------3(1 row)</pre>Если у Вас написало тоже самое, значит функции загружены и работают.Так вот, в поле типа массив мы и будем записывать массив, который получили для картинки (в примере я назвал поле "diff_array"):
**ALTER TABLE some_table ADD COLUMN diff_array integer[]**
Теперь у нас есть картинка и её массив (пусть масив будет "img_array", a id = "img_id"). Как нам выбрать 10 картинок, которые похожы на выбранную не меньше, чем на 60%. Создаем такой sql запрос:<span style="font-size: medium;">**``Select some_table.*, round((icount(some_table.diff_array::int[] &amp; 'img_array'::int[])::numeric / (225)::numeric) * 100, 2) as simillar_percentes FROM some_table WHERE round((icount(some_table.diff_array::int[] &amp; 'img_array'::int[])::numeric / (225)::numeric) * 100, 2) &gt;= 60 AND id != img_id ORDER BY round((icount(some_table.diff_array::int[] &amp; 'img_array'::int[])::numeric / (225)::numeric) * 100, 2) DESC LIMIT 10``**</span>Коротко говоря, основа этого запроса - это "diff_images (diffImages)" функция в классах. Главная функция, по которой мы ищем и сортируем:<span style="font-size: medium;">`` **round((icount(some_table.diff_array::int[] &amp; 'img_array'::int[])::numeric / (225)::numeric) * 100, 2)**``</span>Вместо "img_array" вставляем массив картинки, вместо "img_id" - id картинки (пропустить саму себя), а цыфра 60 - минимальный процент совпадения.## Скорость:
Теперь проверим его производительность.**1 Этап:**<pre lang="sql"># Select count(*) from some_table;count-------33(1 row)# EXPLAIN ANALYZE Select some_table.*, ...Total runtime: 0.916 ms</pre>**2 Этап:**<pre lang="sql"># Select count(*) from some_table;count-------1000(1 row)# EXPLAIN ANALYZE Select some_table.*, ...Total runtime: 14.405 ms</pre>**3 Этап:**<pre lang="sql"># Select count(*) from some_table;count-------10000(1 row)# EXPLAIN ANALYZE Select some_table.*, ...Total runtime: 120.908 ms</pre>Причина медлленой выборки: Sort Method:  top-N heapsort  Memory: 37kB - пришлось перейти на алгоритм сортировки кучи (PostgreSQL также  не настроен, но это не главное). Попробуем хитрее - будем выводить последнии загруженые, которые подходят под условие - не меньше 60% похожести:<pre lang="sql"># Select count(*) from some_table;count-------10000(1 row)# EXPLAIN ANALYZE Select some_table.*, ... ORDER BY id LIMIT 10;Total runtime: 4.106 ms</pre>Как видим проблема в основном с сортировкой при увеличении обьема данных в таблице. Но даже здесь можно выкрутится, выбирая не со всей таблица, а, например, ограничиваясь категорией картинок, и искать только ближайшие совпадения, а не максимальные.Также хочу заметить, что можно ускорить работу алгоритма, уменьшив матрицу. Например 10х10 будет также достаточно с головой. Если потребуется выше точность - матрицу потребуется увеличивать, но при этом будет падать скорость работы.Ну на сегодня все. Спасибо, что дочитали до конца (Спасибо за найденные ошибки Виктору).
