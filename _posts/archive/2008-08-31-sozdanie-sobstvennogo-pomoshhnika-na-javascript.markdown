---
layout: post
title: Создание собственного помощника на JavaScript
wordpress_id: 160
wordpress_url: http://leopard.in.ua/?p=160
categories:
- Ajax
- javascript
- Ruby on Rails
tags:
- Ajax
- javascript
- Ruby on Rails
---
**Проблема**Rails позволяет радоваться многим преимуществам от использования JavaScript в пользовательском интерфейсе, освобождая меня от нелюбимого занятия — соб­ственноручного создания кода JavaScript. В Rails полно магических одно строчных выражений, создающих впечатляющие эффекты пользовательского интер­фейса, для которых не нужно использовать ни одной строчки JavaScript.К сожалению, Rails не решает всех возникающих у меня проблем пользо­вательского интерфейса. И хотя библиотека JavaScript-помощников будет по­полняться (либо в распространяемом ядре, либо в создаваемых пользователями внешних модулях) независимо от того, какой объем свободно распространяемо­го кода станет доступен, при создании веб-приложений с развитым пользо­вательским интерфейсом придется время от времени сталкиваться с какими-нибудь тонкостями, для которых придется создавать свой собственный код JavaScript.Зачастую не находя применения за пределами собственного проекта или ком­пании, эти небольшие фрагменты JavaScript будут повторно использоваться в моих личных творениях.Как превратить неприглядные однострочные вставки JavaScript в собствен­ные магические выражения?<!--more-->**Решение**Сегодня будет слегка задействован и JavaScript, и Ruby. Мы собираемся создать небольшую JavaScript-библиотеку, а затем поместить ее во вспомога­тельный Ruby-метод, который затем можно будет вызывать из представлений. Прочитав [эту статью](http://leopard.in.ua/2008/08/25/mestnoe-redaktirovanie-formy/), можно было усвоить, что встроенное средство InPlaceEditor предоставляет для местного редактирования лишь механизм генерации тексто­вых полей. Для демонстрации создания JavaScript-помощника мы собираемся расширить InPlaceEditor, придав ему способность генерировать также и HTML-тег &lt;select&gt;, чтобы по щелчку на элементе редактирования пользователям открывался список доступных значений, а не просто текстовое поле, в которое они могут вве­сти все, что угодно. Предполагается, что мы будем использовать то же самое при­ложение по управлению адресной книгой, что и там. Если вы еще не работали с этим приложением, создайте миграцию и сгенерируйте временную платформу для модели Contact. А поскольку мы собираемся воспользоваться тех­нологией Ajax, не забудьте включить в файл макета app/views/layouts/contacts.rhtml не­обходимые JavaScript-файлы. Начнем, пожалуй, с упрощенного представления для действия show(). Вот как должен выглядеть файл app/views/contacts/show.rhtml:<pre lang="html">&lt;p&gt;&lt;b&gt;Name:&lt;/b&gt;&lt;%= in_place_editor_field :contact, :name  %&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Country:&lt;/b&gt;&lt;%= in_place_editor_field :contact, :country %&gt;&lt;/p&gt;</pre>В этом представлении предусматривается местное редактирование свойств name() и country() для любого объекта Contact, хранящегося в базе данных. По щелч­ку на названии страны будет открыто текстовое поле, похожее на то, что изобра­жено на следующем рисунке.[![](http://leopard.in.ua/wp-content/uploads/2008/08/screenshot_2.png "screenshot_2")](http://leopard.in.ua/wp-content/uploads/2008/08/screenshot_2.png)Вызов в представлении метода in_place_editor_field() приведет к обыкновенной генерации следующего кода JavaScript (вы сами можете в этом убедиться, про­смотрев исходный HTML-код на странице браузера):<pre lang="javascript">&lt;p&gt;&lt;b&gt;Name:&lt;/b&gt;&lt;span class="in_place_editor_field" id="contact_name_1_in_place_editor"&gt;wer&lt;/span&gt;&lt;script type="text/javascript"&gt;//&lt;![CDATA[new Ajax.InPlaceEditor('contact_name_1_in_place_editor', '/contacts/set_contact_name/1', {rows:1})//]]&gt;&lt;/script&gt;&lt;/p&gt;</pre>Оказывается, не такие уж они и волшебные, эти помощники. Все, на что они способны, — это генерация фрагментов JavaScript и HTML. А это обыкновенное создание текста, который, как оказывается, является кодом JavaScript.Вы, конечно, помните, что мы намеревались создать свое собственное расши­рение InPlaceEditor, чтобы вместо текстового поля браузеру отправлялся тег &lt;select&gt;. Поскольку из только что просмотренного исходного HTML-кода видно, что InPlaceEditor генерирует лишь вызов JavaScript, то для создания нужного нам свой­ства мы вынуждены забраться во внутренности средства InPlaceEditor.Средство InPlaceEditor определено в файле public/javascripts/controls.js. Просматривая его исходный код, можно заметить, что в нем инициализирована связь события щелчка кнопкой мыши с функцией enterEditMode(). В определении этой функции можно проследить вызов createForm(), а в нем — вызов createEditField(). Итак, подво­дя итоги (и избавляя вас от подробностей), щелчок на тексте в средстве местного редактирования приводит к вызову JavaScript-функции createForm( ), которая при установке редактируемого поля зависит, в свою очередь, от функции createEditField(). Функция createEditField() создает либо поле &lt;input&gt; типа "text", либо поле &lt;textarea&gt; и добавляет его к форме.Пока все хорошо, функция createEditField() является подходящей и вполне по­нятной отправной точкой для подмены поведения InPlaceEditor, проявляющегося при создании поля. Для выполнения задуманного в JavaScript имеется масса воз­можностей. Мы не станем вдаваться в подробности осуществления, а воспользу­емся по отношению к подклассу InPlaceEditor преимуществами механизма наследо­вания, имеющегося в библиотеке Prototype JavaScript.Мы создадим свой собственный класс под названием InPlaceSelectEditor, в кото­ром просто возьмем и заменим имевшийся в InPlaceEditor метод createEditField().Давайте в файле in_place_select_editor.js каталога public/javascripts создадим новый класс JavaScript. Если потребуется, этот файл можно будет включать в состав лю­бых страниц. А вот как должно выглядеть содержимое этого файла:**public/javascripts/in_place_select_editor.js**<pre lang="javascript">Ajax.InPlaceSelectEditor = Class.create();Object.extend(Object.extend(Ajax.InPlaceSelectEditor.prototype,Ajax.InPlaceEditor.prototype), {createEditField: function(){var text = (this.options.loadTextURL ? this.options.loadingText : this.getText());this.options.textarea = false;var selectField = document.createElement("select");selectField.update(this.options.selectOptionsHTML ? this.options.selectOptionsHTML : "&lt;option&gt;" + text + "&lt;/option&gt;");selectField.name = this.options.paramName;selectField.value = text;selectField.className = 'editor_field';$A(selectField.options).each(function (opt, index){if (text == opt.value){selectField.selectedIndex = index;}});if (this.options.submitOnBlur)selectField.onblur = this._boundSubmitHandler;this._controls.editor = selectField;if (this.options.loadTextURL)this.loadExternalText();this._form.appendChild(this._controls.editor);}});</pre>Давайте, не углубляясь в рассуждения о внутреннем содержимом InPlaceEditor, коротко рассмотрим данный код JavaScript, чтобы понять все ключевые моменты. Вначале создается новый класс InPlaceSelectEditor, расширяющий класс InPlaceEditor, а затем переписывается метод createEditField(). Начиная с десятой строки для теку­щего значения поля устанавливается переменная text. Затем в тринадцатой строке создается новый элемент &lt;select&gt;, а на пятнадцатой строке ему присваивается имя "value". Действия, которые InPlaceEditor генерирует на сервере, будут ожидать дан­ные в параметре под именем "value".В четырнадцатой строке извлекается значение параметра selectOptionsHTML, ко­торое может быть передано в качестве третьего аргумента (представляющего со­бой хэш JavaScript) в конструктор InPlaceSelectEditor. Значению innerHTML только что созданного тега &lt;select&gt; присваивается либо переданный ему блок параметров, ли­бо одиночный параметр, содержащий текущее значение поля1.В завершение цикл, начинающийся в строке 18, осуществляет последователь­ный перебор каждого параметра, пока не будет найдено текущее значение поля, и устанавливает этот параметр в качестве выбранного.Без этого блока кода поле выбора имело бы непредсказуемое начальное значе­ние, отличное от установленного на данный момент.Теперь, когда код JavaScript уже определен, его нужно включить в страницу через файл макета app/views/layouts/contact.rhtml. Сделать это можно следующим обра­зом:**app/views/layouts/contacts.rhtml**<pre lang="rails">&lt;%= javascript_include_tag 'in_place_select_editor' %&gt;</pre>Теперь давайте создадим простое демонстрационное представление, чтобы посмотреть этот новый класс JavaScript в действии. Создайте в каталоге app/views/contacts/demo.rhtml новое представление со следующим кодом:**app/views/contacts/demo.html**<pre lang="javascript">&lt;span class="in_place_editor_field" id="an_element_we_want_to_edit"&gt;Some text&lt;/span&gt;&lt;script type="text/javascript"&gt;new Ajax.InPlaceSelectEditor('an_element_we_want_to_edit', 'url',{selectOptionsHTML: "&lt;option value='1'&gt;One&lt;/option&gt;" +"&lt;option value='2'&gt;Two&lt;/option&gt;" +"&lt;option value='3'&gt;Three&lt;/option&gt;"});&lt;/script&gt;</pre>Здесь используются те же параметры, которые передавались оригинальному InPlaceEditor, за исключением того, что третий (необязательный) хэш-аргумент спо­собен принять дополнительный ключ selectOptionsHTML.Теперь, когда все, что касается JavaScript, работает, как вообще избежать необ­ходимости программирования на JavaScript? Настало время создать помощника!Мы уже видели, что используемые в Rails помощники, созданные на JavaScript, по сути, всего лишь генерируют текст, который и является кодом JavaScript. Что же нужно сделать, чтобы сгенерировать такой вспомогательный метод? В общем-то, нужно сгенерировать код, эквивалентный тому, что мы написали вручную в пре­дыдущем демонстрационном примере.Мы немного схитрим и поищем в файле java_script_macros_helper.rb в Action Pack (а потом скопируем) определение метода in_place_editor_field( ). Реализация нового помощника будет заключаться в двух методах, следующих за кодом, лежащим в основе InPlaceEditor. Чтобы он был доступен всем представлениям, мы поместим его в файл app/helpers/application_helper.rb. Назовем первый метод in_pla-ce_select_editor_field( ). Поскольку мы хотим реализовать возможность передачи объ­екта и имени поля, задача метода in_place_select_editor_field( ) состоит в том, чтобы ус­тановить на основе предоставленных ему объекта и имени поля параметры id и url для передачи JavaScript классу InPlaceSelectEditor. Вот как он реализован:**app/helpers/application_helper.rb**<pre lang="ruby">def in_place_select_editor_field(object, method, tag_options = {}, in_place_editor_options = {})tag = ::ActionView::Helpers::InstanceTag.new(object, method, self)tag_options = {:tag =&gt; "span", :id =&gt; "#{object}_#{method}_#{tag.object.id}_in_place_editor", :class =&gt; "in_place_editor_field"}.merge!(tag_options)in_place_editor_options[:url] = in_place_editor_options[:url] || url_for({ :action =&gt; "set_#{object}_#{method}", :id =&gt; tag.object.id })tag.to_content_tag(tag_options.delete(:tag), tag_options) +in_place_select_editor(tag_options[:id], in_place_editor_options)end</pre>Теперь можно заметить, что этот метод передает полномочия методу in_place_ select_editor( ), чья работа заключается в генерации текста JavaScript, который будет вставлен в исполняемое представление. А вот как метод in_place_select_ editor( ) должен выглядеть:**app/helpers/application_helper.rb**<pre lang="ruby">def in_place_select_editor(field_id, options = {})function = "new Ajax.InPlaceSelectEditor("function &lt;&lt; "'#{field_id}', "function &lt;&lt; "'#{url_for(options[:url])}'"function &lt;&lt; (', ' + options_for_javascript({'selectOptionsHTML' =&gt;%('#{escape_javascript(options[:select_options].gsub(/\n/,""))}')})) if options[:select_options]function &lt;&lt; ')'javascript_tag(function)end</pre>Положительный побочный эффект от способа предоставления параметра selectOptionsHTML состоит в том, что он упрощает применение помощников Rails, предназначенных для работы с параметрами формы.Чтобы довести работу до логического завершения, рассмотрим файл app/views/ contacts/show.rhtml, модифицированный под использование нашего нового помощ­ника. Заметьте, что перечень стран предоставляется встроенным в Rails помощ­ником country_options_for_select( ).**app/views/ contacts/show.rhtml**<pre lang="javascript">&lt;p&gt;&lt;b&gt;Name:&lt;/b&gt;&lt;%= in_place_editor_field :contact, :name, {}, :rows =&gt; 1 %&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Country:&lt;/b&gt;&lt;%= in_place_select_editor_field(:contact,:country,{},:select_options =&gt; country_options_for_select)%&gt;&lt;/p&gt;</pre>После щелчка на названии страны форма приобретет вид, показанный на рис.[![](http://leopard.in.ua/wp-content/uploads/2008/08/screenshot-1_2.png "screenshot-1_2")](http://leopard.in.ua/wp-content/uploads/2008/08/screenshot-1_2.png)Ну вот и все.**P.S.**В наших помощниках, in_place_select_editor_field( ) и in_place_select_editor_field( ), содержится слишком много повторений. Встроенные JavaScript-помощники in_place_editor_field() и in_place_editor( ) не делались с прицелом на расширение.Не так уж и трудно сделать их более универсальными, чтобы к ним было легче подключиться, и за счет этого уменьшить и упростить самодельные вспомога­тельные методы. Но врятли это будет так наглядно :)
