---
layout: post
title: С PHP на ROR. Часть первая
wordpress_id: 771
wordpress_url: http://leopard.in.ua/?p=771
categories:
- Ruby on Rails
- PHP
tags:
- Ruby on Rails
- PHP
---
Начну небольшую серию статей как я PHP программист осваивали потихоньку переходил на Ruby on Rails. Тут я буду объяснять часто требовательные функционал на PHP и его аналог на Ruby on Rails. Ну что же, начнем!<!--more-->## Масивы (Arrays)
Существует много различных способов создания массива (array) в PHP. Что нам нужно знать, так это то, что объекты Array и Hash включают в себя разные функциональные особенности PHP массивов.### Сортировка Масивов
Только чисельно-индексный массив может быть отсортирован в Ruby. Создать такой массив можно несколькими путями. Самый популярный - использование квадратных скобок с разделителем в виде запятой. Также используется %w{} для создания массива из списка строк. Ruby не сохраняет индексацию массива, как это делает PHP массив. Ruby массивы - это простые стеки, где индекс определяется лишь позицией элемента. Не возможно пропустить элемент Ruby массива.**PHP**<pre lang="php">array = array('chicago', 'london', 'paris');var_export($array);// =&gt; array(0 =&gt; 'chicago', 1 =&gt; 'london', 2 =&gt; 'paris')</pre>**Ruby**<pre lang="ruby">array = ["chicago", "london", "paris"]# orarray = %w{ chicago london paris }p array# =&gt; ["new york", "london", "paris"]</pre>## Ассоциативные массивы
Для создания ассоциативных массивов в Ruby используется хэш (hash). Наиболее распространенным синтаксисом для создания хэша в Ruby используются фигурные скобки с разделенных запятыми список ключевых пар. Запомните, что хеш не упорядочен. Если Вам нужно упорядочить ассоциативный массив, Вам потребуется создать массив объектов.**PHP**<pre lang="php">$array = array('age' =&gt; 26, 'name' =&gt; 'Joe', 'country' =&gt; 'USA');var_export($array);// =&gt; array('age' =&gt; 26, 'name' =&gt; 'Joe', 'country' =&gt; 'USA')</pre>**Ruby**<pre lang="ruby">p {:age =&gt; 26, :name =&gt; "Joe", :country =&gt; "USA"}# =&gt; {:age=&gt;26, :country=&gt;"USA", :name=&gt;"Joe"}</pre>## Смешаные массивы
Можем создавать массивы с сочетание числовых и строковых ключей в Ruby с помощью хэшей (hash). PHP автоматически присваивает числовой индекс элементов без определенного ключа. Ruby отличается тем, что требует указать ключевое значение каждого элемента.**PHP**<pre lang="php">$array = array('age' =&gt; 25, 1, 'name' =&gt; 'Joe', 2);var_export($array);// =&gt; array('age' =&gt; 25, 0 =&gt; 1, 'name' =&gt; 'Joe', 1 =&gt; 2)</pre>**Ruby**<pre lang="ruby">hash = {:age =&gt; 25, 0 =&gt; 1, :name =&gt; "Joe", 1 =&gt; 2}p hash# =&gt; {0=&gt;1, :age=&gt;25, 1=&gt;2, :name=&gt;"Joe"}</pre>## is_array
Мы можем убедиться, что переменная массив используя объект # is_a?.**PHP**<pre lang="php">$colors = array('red', 'green', 'blue');$result = is_array($colors);var_export($result);// =&gt; true</pre>**Ruby**<pre lang="ruby">colors = ["red", "green", "blue"]p colors.is_a?(Array)# =&gt; true</pre>## count
Мы можем подсчитать количество элементов в массиве Ruby используя Array #length метод.**PHP**<pre lang="php">$numbers = array(1, 2, 3);print count($numbers);// =&gt; 3</pre>**Ruby**<pre lang="ruby">numbers = [1, 2, 3]puts numbers.length# =&gt; 3</pre>Важно помнить о том, что в то время как мы можем пропустить элементы массива в PHP, мы не можем это сделать в Ruby. Если добавить к десятому ключу элемент массива, Ruby будет заполнить недостающие элементы с нулевыми.**PHP**<pre lang="php">$numbers = array(1, 2);$numbers[10] = 3;print count($numbers);// =&gt; 3</pre>**Ruby**<pre lang="ruby">numbers = [1, 2]numbers[10] = 3puts numbers.length# =&gt; 11</pre>## list
Мы можем сделать эквивалентно PHP перечень элементов в Ruby с помощью параллельного назначения. В Ruby мы можем присвоить разделенных запятыми переменные элементов массива с помощью обычной запятой.**PHP**<pre lang="php">$attributes = array('Joe', 25, 'blonde');list($name, $age, $hair) = $attributes;print $name; // =&gt; 'Joe'print $age;  // =&gt; 25print $hair; // =&gt; 'blonde'</pre>**Ruby**<pre lang="ruby">attributes = ["Joe", 25, "blonde"]name, age, hair = attributesputs name # =&gt; "Joe"puts age  # =&gt; 25puts hair # =&gt; "blonde"</pre>## range
Ruby может работать с диапазоном объектов чисел или строк.**PHP**<pre lang="php">$sequence = range(0, 3);var_export($sequence);// =&gt; array(0 =&gt; 0, 1 =&gt; 1, 2 =&gt; 2, 3 =&gt; 3)foreach ($sequence as $item) {    print "$item, ";}// =&gt; 0, 1, 2, 3,</pre>**Ruby**<pre lang="ruby">sequence = 0..3p sequence# =&gt; 0..3sequence.each {|item| print "#{item}, " }# =&gt; 0, 1, 2, 3,</pre>Точно так же, как в PHP, мы можем создать iterable ряд последовательных строк.**PHP**<pre lang="php">$alphas = range('a', 'd');var_export($alphas);// =&gt; array(0 =&gt; 'a', 1 =&gt; 'b', 2 =&gt; 'c', 3 =&gt; 'd')foreach ($alphas as $item) {    print "$item, ";}// =&gt; a, b, c, d,</pre>**Ruby**<pre lang="ruby">alphas = 'a'..'d'p alphas# =&gt; "a".."d"alphas.each {|item| print "#{item}, " }# =&gt; a, b, c, d,</pre>## in_array
Мы можем проверить элемент на существования в массиве с помощью функции Array#include?.В PHP in_array имеет строгое аргументирование, который будет рассматривать какого типа объект. Ruby считает число 1 и строку '1' как же самое, и всегда будет действовать в эквивалент с PHP если присвоить strict = true для этой функции.**PHP**<pre lang="php">$fruit = array('apple', 'banana', 'kiwi');$result = in_array('apple', $fruit, true);var_export($result);// =&gt; true</pre>**Ruby**<pre lang="ruby">fruit = ["apple", "banana", "kiwi"]p fruit.include?("apple")# =&gt; true</pre>Точно так же, как PHP, Ruby можете проверить наличие элемента в массиве, даже если этот элемент массива (или любой другой объект).**PHP**<pre lang="php">$list = array(array('a', 'b'), 'c');$result = in_array(array('a', 'b'), $list);var_export($result);// =&gt; true</pre>**Ruby**<pre lang="ruby">list = [["a", "b"], "c"]p list.include?(["a", "b"])# =&gt; true</pre>Думаю на сегодня хватит. Удачи!
